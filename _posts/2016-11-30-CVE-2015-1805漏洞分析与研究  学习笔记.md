## CVE-2015-1805漏洞分析与研究  学习笔记

####背景知识

root（uid=2000->0）

- 修改rom包，刷机，刷入系统

- 刷入recovery

- 利用本地提提权漏洞


本地提权方法：

- setresuid（0,0,0）

- commit_cred（prepare_kernel_cred（0））

- DKOM task_struct->Cred

- Framework漏洞   system->root



CVE-2015-1805漏洞：在linux内核中的管道读写过程中，数据不同步，导致拷贝越界、读写错位，导致任意地址读写任意值。



####漏洞原理

​       管道处理中的iov_base指向一个有读写权限的用户态地址，iov_len指向读写数据。
​       首先pipe_read（）函数会先循环读取iovec结构，并且通过iovfault_in_pages_write（）函数判断iov->len是否大于0，且iov->base指向地址是否可写且处于用户态，之后返回atomic。
​       如果atomic为1，pipe_iov_copy_to_user拷贝出现错误，进入redo的逻辑，再次调用
pipe_iov_copy_to_user函数进行拷贝，且将stomic置为0.但pipe_iov_copy_to_user的第三个参数chars并没有更新，还是会拷贝total_len大小的数据。

```static int
pipe_iov_copy_to_user(struct iovec *iov, const void *from, unsigned long len,
             int atomic)
{
    unsigned long copy;
    while (len > 0)
    {
        while (!iov->iov_len)
             iov++;
        copy = min_t(unsigned long, len, iov->iov_len);
        if (atomic
        {           
    if (__copy_to_user_inatomic(iov->iov_base, from, copy))
                 //(4)
                 return -EFAULT;
        }
        else
       {
            if (copy_to_user(iov->iov_base, from, copy))
                 //(4)
                 return -EFAULT;
        }
        from += copy;
        len -= copy;
        iov->iov_base += copy;
        //每次对iov->iov_len进行更新`
        iov->iov_len -= copy;
    }
    return 0;
}
```